---
title: "FastAPI：响应处理与序列化控制"
showAuthor: false
date: 2025-04-27
description: ""
slug: "fastapi-03"
tags: ["Python", "FastAPI"]
series: ["FastAPI"]
series_order: 3
draft: false
---

<!-- 渲染公式 -->
{{< katex >}}

<!-- --------------------------- -->

<!-- # FastAPI 工程化开发指南 - 第三篇：响应处理与序列化控制 -->

{{< alert "bell" >}}
API 的输出质量直接关系到客户端的集成体验与系统性能。本文将深入 FastAPI 的响应处理机制，包括利用响应模型进行数据清洗、引入高性能 JSON 序列化库 `orjson` 提升吞吐量、符合 RESTful 语义的状态码管理，以及如何构建全局统一的异常处理体系。
{{< /alert >}}


## 1. 响应模型的数据治理

在上一篇中，提到了 `UserResponse` 模型的继承设计。这里将深入 `response_model` 在实际运行时的核心行为：**数据清洗（Data Validation & Filtering）**。

### 1.1 安全性与过滤
`response_model` 的最大价值在于它充当了 API 的“出口安检”。无论后端逻辑或数据库返回了多少冗余或敏感字段（如 `password_hash`, `internal_id`），只要不在 `response_model` 定义中，这些字段在序列化阶段就会被无情丢弃。

```python
# 数据库模型可能包含所有字段
class DBUser:
    def __init__(self):
        self.username = "admin"
        self.password = "secret"  # 敏感数据
        self.role = "superuser"

# 响应模型仅定义允许公开的字段
class PublicUser(BaseModel):
    username: str

@app.get("/user", response_model=PublicUser)
async def get_user():
    # 即使这里返回了完整的 DB 对象
    return DBUser() 
    # 客户端收到的 JSON 仅为: {"username": "admin"}
```

### 1.2 稀疏字段优化
对于包含大量可选字段（`Optional`）的模型，默认返回 `null` 可能会导致响应体积膨胀。使用 `response_model_exclude_unset=True` 可以仅返回显式赋值的字段。

```python
@app.get("/items/{id}", response_model=Item, response_model_exclude_unset=True)
async def read_item(id: str):
    # 如果 Item 模型中有 description: str | None = None
    # 且数据库中该值为默认值 None
    # 则返回的 JSON 中完全不会出现 "description" 键
    return item_data
```


## 2. 性能优化：引入 ORJSON

FastAPI 默认使用 Python 标准库 `json` 进行序列化。在处理大规模数据（如返回数万行的列表）时，标准库的性能往往成为瓶颈。**ORJSON** 是一个基于 Rust 开发的高性能 JSON 库，其序列化速度通常是标准库的数倍至数十倍。

### 2.1 替换 DefaultResponse
要在 FastAPI 中全局启用 ORJSON，只需在应用初始化时指定 `default_response_class`。

1.  **安装依赖**：
    ```bash
    pip install orjson
    ```

2.  **配置应用**：
    ```python
    from fastapi import FastAPI
    from fastapi.responses import ORJSONResponse

    app = FastAPI(default_response_class=ORJSONResponse)
    ```

### 2.2 处理特殊数据类型
`ORJSONResponse` 的另一个优势是它原生支持 `numpy.ndarray`, `datetime`, `UUID` 等类型的序列化，无需像标准库那样编写自定义 Encoder。

```python
import numpy as np
from fastapi.responses import ORJSONResponse

@app.get("/vector", response_class=ORJSONResponse)
async def get_vector():
    # orjson 可以直接序列化 numpy 数组，无需 tolist()
    data = np.random.rand(1000)
    return {"vector": data}
```


## 3. 状态码管理与语义化

硬编码数字状态码（如 `200`, `404`）降低了代码的可读性。FastAPI 推荐使用 `fastapi.status` 模块提供的常量。

### 3.1 常用状态码映射
在 RESTful API 设计中，区分不同的成功状态至关重要：
*   `200 OK`：通用查询成功、更新成功（PUT）。
*   `201 Created`：资源创建成功（POST）。
*   `202 Accepted`：请求已接受进入后台队列，尚未处理完成。
*   `204 No Content`：删除成功（DELETE），响应体必须为空。

### 3.2 代码实践
```python
from fastapi import FastAPI, status, Response

@app.post("/items/", status_code=status.HTTP_201_CREATED)
async def create_item(item: Item):
    return {"id": "new_id"}

@app.delete("/items/{id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_item(id: str):
    # 执行删除逻辑...
    # 204 响应不能有 Body，直接返回 Response 对象
    return Response(status_code=status.HTTP_204_NO_CONTENT)
```


## 4. 全局异常处理体系

在工程实践中，不仅需要处理正常的响应，更需要统一异常的返回格式。直接抛出 Python 原生异常（如 `KeyError`）会导致服务器返回 `500 Internal Server Error` 且不包含任何有效信息，这是不合格的 API 设计。

### 4.1 自定义 HTTPException
虽然 FastAPI 提供了 `HTTPException`，但在大型项目中，通常建议封装业务异常基类。

### 4.2 全局异常处理器 (Global Exception Handlers)
通过 `@app.exception_handler` 捕获特定异常，统一返回 JSON 格式的错误信息。

```python
from fastapi import Request
from fastapi.responses import JSONResponse

# 1. 定义自定义业务异常
class UnicornException(Exception):
    def __init__(self, name: str):
        self.name = name

# 2. 注册异常处理器
@app.exception_handler(UnicornException)
async def unicorn_exception_handler(request: Request, exc: UnicornException):
    return JSONResponse(
        status_code=418,
        content={"message": f"Oops! {exc.name} did something wrong."},
    )

# 3. 覆盖 FastAPI 默认的验证异常 (RequestValidationError)
# 使得参数校验错误的返回格式符合内部规范
from fastapi.exceptions import RequestValidationError

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request, exc):
    return JSONResponse(
        status_code=422,
        content={
            "code": 422,
            "message": "参数校验失败",
            "detail": exc.errors() # 保留 Pydantic 的详细错误信息
        },
    )
```

这种机制确保了无论系统内部发生何种错误（业务逻辑错误、数据库连接错误、参数校验错误），前端收到的永远是结构一致的 JSON（如都包含 `code`, `message`），极大地降低了前端对接的复杂度。


## 总结

1.  **响应清洗**：`response_model` 是数据安全的最后一道防线，务必定义专门的 Output Schema。
2.  **高性能序列化**：在数据密集型应用中，替换为 `ORJSONResponse` 是最低成本的性能优化手段。
3.  **RESTful 语义**：严格使用 `status` 常量，区分 `200`, `201`, `204` 的使用场景。
4.  **异常统一**：杜绝直接抛出 500 错误，通过全局 `exception_handler` 建立标准的错误响应协议。
